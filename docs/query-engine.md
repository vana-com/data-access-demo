Query Engine
Description
The query engine is responsible for indexing all refined data points on the Vana network and servicing query requests against this data
It should respond to query requests synchronously after initial indexing is complete
It should only be accessible from the compute engine (not open to the internet)
Query Engine Payment
Payment is required to get the results of executed queries
Payment is only for data access, not compute (for v0). We can keep this simple at first and require payment in $VANA, but this could eventually be paid in various $DLPT depending on which schemas, tables and columns are queried, where the query engine can buy-and-burn $DLPT from $VANA.
For v0, the cost is deterministic and requires up-front payment from the caller to the compute engine
Once a query is run, the query engine will charge the compute engine for the payment amount and will only release the results after a successful payment
Funds from the query engine are redistributed to the DLP owners whose data was accessed
Topology (Medium term)
The query engine uses a federated architecture to securely access data stored across multiple schema-specific TEEs. Each schema's data is isolated within its own TEE, and queries are handled by separate, stateless coordinator nodes. When a query is received, the coordinator:
Authenticates and checks permissions against the smart contract.
Splits queries into subqueries per data schema.
Requests temporary authorization from each schema TEE, which verifies permissions and returns a short-lived token.
Executes authorized subqueries directly against schema TEEs.
Collects and combines results from schema TEEs before returning to the caller.
Tokens automatically expire once queries complete or after a timeout.
Data Ingestion
Detailed design in Data Ingestion (v0) — Design Document
Initialization step (can take several hours/days)
For each schema definition, download all file refinement DBs through the Data Registry from IPFS and aggregate them into a single DB per schema (refinerId)
How is the refined data encrypted? Discussion in Slack: https://vana-org.slack.com/archives/C06V0MTPR4Z/p1741112409930629?thread_ts=1741042987.301699&cid=C06V0MTPR4Z
Short term: each refinement is encrypted with a new DLP-specific public key, only used by the query engine (given to the DLP by Vana), and a permission is added to the data registry for that file. The keypair is generated by a trusted person in Vana.
Long term: a flow in which users encrypt their file keys against a key managed by Lit Protocol, that only releases it to a verifiably secure query engine environment. (is this possible?)
Implementation: lightweight FastAPI application that can query across multiple (encrypted) libsql databases
Keeping data fresh: a background worker will listen for the RefinementAdded event from the Data Registry and index the data point (add the refined data point to the corresponding aggregate schema DB)
Runs within a TEE
Supports only read-only queries (enforced by a read-only DB role)
Query Engine Contract
Goal: primarily used to permission data, but can later be expanded to track queries onchain
Only schema owners can add a permission for granular access to schemas, tables and columns owned by them, after they have offchain agreements with their data access users. The schema owner can add a permission for anyone with the 0x0 address grantee field.
The schema owners can revoke a permission granted by them (4/7 plan) or adjust the price in the permission (future plan).
A PermissionApprovalUpdated or PermissionPriceUpdated  event will be emitted
In the future, pricing per datapoint can be tracked here

struct Permission {
address grantee; // Optional: Address having the permission. This permision is granted to anyone if grantee is the zero address. 
uint256 refinerId;  // Refiner ID
string tableName;  // Optional: Table name (empty string if schema-level)
string columnName; // Optional: Column name (empty string if table-level)
bool approved;     // Whether the request has been approved
uint256 price;     // Price for each data point
}

mapping(uint256 => Permission) public permissions;
function addPermission(grantee, refinerId, tableName, columnName, price)

function addGenericPermission(
        uint256 refinerId,
        string calldata tableName,
        string calldata columnName,
        uint256 price
    ) external

function updatePermissionApproval(permissionId, approved) // Schema owner to approve or revoke permissions

function getPermissions(refinerId, address) // Get a list of all permissions the address has for a refinerType, including generic permissions that the schema owner gives to anyone. If the address is the zero address, return all generic permissions.

event PermissionAdded(grantee, schemaId, tableName, columnName, permissionId) // Emitted when a new permission is added 

event PermissionApprovalUpdated(permissionId, approved) // Emitted when a request is approved/revoked
Endpoints
Submit a new query across various schemas
The caller (address that submitted the query job) is determined by the signature, and the DLP’s permissions are checked by an offchain service with onchain permissions
The query engine receives a query: SELECT artist_name, track_name FROM tracks LEFT JOIN artists ON artists.id = tracks.artist_id;
It breaks it down into an abstract syntax tree of the tables and columns required:
[{tracks: ['track_name', 'artist_id']}, {artists: ['artist_name', 'id']}]
It gets all the permissions available for the given refinerId onchain for the DLP
It maps through them, orders by permission ID (so the most recent permission and price are checked first), and checks that valid permissions exist for the requested tables and columns, and uses that to build the price
Query is executed immediately, and the results are stored in a temporary table
(for v1) can we estimate the cost first by running `SELECT COUNT (query)`?
Response includes a query ID, where users can see how many rows they would receive
Payment is required to access the data, and the cost is returned

POST /query
Headers
{
	"x-query-signature": "0x1234..."  // Signed query, used to derive caller address
}

Request
{
      	"query": "select count(*) from tweets where user_id = ?",
      	"params": [12345],
      	"refinerId": 12,
"job_id": 456 // for payments, and getting the job owner
}

Response
{
	"query_id": "abc123",
  	"cost": 0.15 x 10e18,  // in VANA
"payment_status": "pending",
"query_status": "success",
"queried_at": "2025-02-20T14:00:00Z",
"expires_at": "2025-02-21T14:00:00Z",
"row_count": 1500,
}

Get the results of a query
Data is only returned once payment is made
Link to an SQLite file of the results, stored on the TEE, downloadable from there until it expires and is deleted
Data expires after a certain time, after which the query_status is expired
Check if payment is made: check the status of the contract call requestPaymentInVana to the query engine contract. The function sends a payment request to the compute engine contract with jobId, refinerId and cost.
If enough funds aren’t available in the compute engine, the request fails 
In the future when we introduce DLP tokens, we can spot-purchase the DLP token using $VANA and then burn or send it to the DLPs

GET /query/:query-id
Headers
{
	"x-query-signature": "0x1234..."  // Signed query, used to derive caller address
}

Response
{
"query_results": "https://phala-3.com/link-to-temp-sqlite-file-in-tee",
"payment_status": "paid", // or pending if payment not made yet
"query_status": "success",
"queried_at": "2025-02-20T14:00:00Z",
"expires_at": "2025-02-21T14:00:00Z",
"row_count": 1500
}
